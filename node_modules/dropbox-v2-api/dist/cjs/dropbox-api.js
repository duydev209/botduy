"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const request_1 = __importDefault(require("request"));
const stream_1 = __importDefault(require("stream"));
const compress_json_1 = require("compress-json");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const url_1 = require("url");
const RPC_RESOURCE_CATEGORY = 'rpc';
const UPLOAD_RESOURCE_CATEGORY = 'upload';
const DOWNLOAD_RESOURCE_CATEGORY = 'download';
const DB_HEADER_API_ARGS = 'Dropbox-API-Arg';
const DB_API_RESULT_HEADER_NAME = 'dropbox-api-result';
const OAUTH2_AUTHORIZE = 'https://www.dropbox.com/1/oauth2/authorize';
const OAUTH2_TOKEN = 'https://api.dropboxapi.com/1/oauth2/token';
// https://www.dropbox.com/developers/reference/json-encoding
const charsToEncode = /[\u007f-\uffff]/g;
// This function is simple and has OK performance compared to more
// complicated ones: http://jsperf.com/json-escape-unicode/4
function http_header_safe_json(v) {
    return JSON.stringify(v).replace(charsToEncode, function (c) {
        return '\\u' + ('000' + c.charCodeAt(0).toString(16)).slice(-4);
    });
}
const updateRequestOptsFnList = [
    /* For requests, which requires auth header, set valid header */
    (requestOpts, { auth }, userOpts, config) => {
        if (auth !== 'noauth') {
            if (!config.token) {
                throwError('No "token" specified!');
            }
            requestOpts.headers['Authorization'] = `Bearer ${config.token}`;
        }
    },
    /* If resource requires upload stream, provide valid header */
    (requestOpts, { format }, userOpts) => {
        if (format === 'upload') {
            requestOpts.headers['Content-Type'] = 'application/octet-stream';
        }
    },
    /* Sets request parameter as request body (for RPC requests) or as header (for DOWNLOAD / UPLOAD requests) */
    (requestOpts, resourceDescription, userOpts, config) => {
        const resourceCategory = resourceDescription.format;
        const userParameters = userOpts.parameters;
        if (resourceCategory === RPC_RESOURCE_CATEGORY) {
            //RPC, put it as body
            requestOpts.body = resourceDescription.request ? userParameters : null;
        }
        else {
            //if not RPC, then we have 2 options: download or upload type request
            requestOpts.headers[DB_HEADER_API_ARGS] = isObject(userParameters) ? http_header_safe_json(userParameters) : '';
        }
    }
];
//------------------------------------------------------------------------------------
function generateResourcesHandlingFunctions(resourcesDescriptionList, config) {
    const resourcesHandlingFunctions = {};
    Object.keys(resourcesDescriptionList).forEach((resourceName) => {
        const resourceDescription = resourcesDescriptionList[resourceName];
        const resourceCategory = resourceDescription.format;
        resourcesHandlingFunctions[resourceName] = function (userOpts, userCb) {
            //create default request object
            const requestOpts = createDefaultRequestOptObject(resourceDescription);
            //prepare requestOpts based on userOpts, config, etc.
            updateRequestOptsFnList.forEach((updateRequestOptsFn) => updateRequestOptsFn(requestOpts, resourceDescription, userOpts, config));
            const callback = userCb && prepareCallback(userCb);
            //send request
            if (resourceCategory === UPLOAD_RESOURCE_CATEGORY) {
                //it's upload type request, so pipe
                requestOpts.headers['Content-Type'] = 'application/octet-stream';
                if (userOpts.readStream) {
                    // read stream specified, so pipe it
                    return userOpts.readStream.pipe((0, request_1.default)(requestOpts, callback));
                }
                else {
                    // readStream not specified, so return writable stream
                    return (0, request_1.default)(requestOpts, callback);
                }
            }
            else if (resourceCategory === DOWNLOAD_RESOURCE_CATEGORY) {
                return (0, request_1.default)(requestOpts, callback).pipe(createTransformStream());
            }
            else {
                //ordinary api call request
                return (0, request_1.default)(requestOpts, callback);
            }
            function prepareCallback(userCb) {
                return (err, response, body) => {
                    if (err) {
                        return userCb(err, null, response);
                    }
                    const responseContentType = response.headers['content-type'];
                    const statusCode = response.statusCode;
                    const handleResponseByContentType = {
                        /* it's content-stream response type, so response object is located inside header */
                        'application/octet-stream': () => {
                            const dropboxApiResultContent = response.headers[DB_API_RESULT_HEADER_NAME];
                            return dropboxApiResultContent && userCb(null, JSON.parse(dropboxApiResultContent), response);
                        },
                        /* it's ordinary RPC response, so result object is located inside body */
                        'application/json': () => {
                            const json = body;
                            if (statusCode === 200) {
                                return userCb(null, json, response);
                            }
                            else {
                                json.code = statusCode;
                                return userCb(json, null, response);
                            }
                        },
                        /* text type response */
                        'text/plain; charset=utf-8': () => {
                            const text = body;
                            if (statusCode === 200) {
                                return userCb(null, text, response);
                            }
                            else {
                                return userCb({
                                    code: statusCode,
                                    text: text
                                }, null, response);
                            }
                        }
                    };
                    const responseHandlerFn = handleResponseByContentType[responseContentType];
                    if (responseHandlerFn) {
       